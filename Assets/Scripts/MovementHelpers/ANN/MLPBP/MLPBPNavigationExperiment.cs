// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Xml;
using System.Collections;
using SharpNeat.Domains;
using UnityEngine;

public class MLPBPNavigationExperiment
{
    private BlackBoxEvaluator blackBoxEvaluator;
    string _name, _description;
    int _populationSize, _lifespan, _generation = 0, _inputCount = 13, _outputCount = 9;
    double _learnRate, _momentum, _optimalFitness;
    bool generationComplete = true;

    public int CurrentGeneration { get { return _generation; } }
    public int LifeSpan { get { return _lifespan; } }
    public int _totalEvaluationCount = 0;
    public double _maxFitness = 0, _meanFitness = 0;

    System.Random _rng = new System.Random();

    MLPBPBlackBox[] _neuralNets;

    #region Constructors
    public MLPBPNavigationExperiment(BlackBoxEvaluator blackBoxEvaluator, double optimalFitness)
    {
        this.blackBoxEvaluator = blackBoxEvaluator;
        _optimalFitness = optimalFitness;
    }
    #endregion

    #region Public Methods

    public void Initialize(string name, XmlElement xmlConfig)
    {
        _name = name;
        _populationSize = XmlUtils.GetValueAsInt(xmlConfig, "PopulationSize");
        _description = XmlUtils.TryGetValueAsString(xmlConfig, "Description");
        _lifespan = XmlUtils.GetValueAsInt(xmlConfig, "Lifespan");
        _learnRate = XmlUtils.GetValueAsDouble(xmlConfig, "MLPBPLearningRate");
        _momentum = XmlUtils.GetValueAsDouble(xmlConfig, "MLPBPMomentum");

        _neuralNets = new MLPBPBlackBox[_populationSize];
        for (int i = 0; i < _populationSize; i++)
        {
            _neuralNets[i] = new MLPBPBlackBox(_inputCount, _outputCount, i, _rng);
        }
    }

    public void StartContinueMainThread()
    {
        Coroutiner.StartCoroutine(AlgorithMainThread());
    }

    public IEnumerator AlgorithMainThread()
    {
        while (true) {
            while (!generationComplete) yield return null;
            PerformOneGeneration();
        }
    }

    private void PerformOneGeneration()
    {
        int completed = 0;
        double totalFitness = 0;
        double tmpMaxFitness = 0;
        generationComplete = false;
        foreach (MLPBPBlackBox blackBox in _neuralNets)
        {
            int blackBoxId = blackBox._id;
            blackBoxEvaluator.Evaluate(2, blackBox, (double fitness) =>
            {
                totalFitness += fitness;
                if (fitness > tmpMaxFitness)
                {
                    tmpMaxFitness = fitness;
                }

                _neuralNets[blackBoxId].fitness = fitness;

                completed++;
                _totalEvaluationCount++;
                if (completed == _populationSize)
                {
                    _maxFitness = tmpMaxFitness;
                    _meanFitness = totalFitness / _populationSize;
                    trainNeuralNets();
                    generationComplete = true;
                    _generation++;
                }
            });
        }
    }

    private void trainNeuralNets()
    {
        foreach (MLPBPBlackBox blackBox in _neuralNets)
        {
            double mu = _meanFitness;
            double sigma = _maxFitness - _meanFitness;

            double error = gaussian(blackBox.fitness, mu, sigma);
            blackBox.trainWithError(error, _learnRate, _momentum);
        }
    }

    private double gaussian(double x, double mu, double sigma)
    {
        return Math.Exp(- Math.Pow((x - mu), 2) / (2 * Math.Pow(sigma, 2)));
    }

    #endregion
}

